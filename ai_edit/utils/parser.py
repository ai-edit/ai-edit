"""
Enhanced AI response parser that supports both full-file content updates
and unified diffs / patches.

Key Features Added
------------------
1. Recognises fenced code blocks whose *language* is ``diff`` or ``patch``.
2. Returns a ``kind`` field in each operation dictionary with values
   ``"full"`` or ``"diff"``.
3. Maintains backward-compatibility with the original public interface.
"""

from __future__ import annotations

import re
from typing import Any, Dict, List

__all__ = ["parse_ai_response"]


_DIFF_LIKE_LANGUAGES = {"diff", "patch"}


def parse_ai_response(response: str) -> List[Dict[str, Any]]:
    """
    Parse *response* coming from the AI assistant.

    The function detects (in order of priority):

    1. XML-like ``<tool_call>`` blocks generated by the assistant if it
       needs additional context (handled by :pyfunc:`_parse_tool_calls`).
    2. Fenced code blocks that convey file modifications – either the
       *entire* file content (``kind="full"``) or a unified diff /
       patch (``kind="diff"``).

    Returns
    -------
    List[Dict[str, Any]]
        A list of operation dictionaries with (at minimum) ``type``,
        ``path``, ``content`` and ``kind`` keys.
    """
    # Tool calls have precedence.  If they exist we *only* return them.
    tool_ops = _parse_tool_calls(response)
    if tool_ops:
        return tool_ops

    return _parse_code_blocks(response)


# --------------------------------------------------------------------------- #
# Internal helpers
# --------------------------------------------------------------------------- #
_FILE_BLOCK_RE = re.compile(r"```(\w+):(.+)")


def _parse_code_blocks(response: str) -> List[Dict[str, Any]]:
    """
    Extract file operations from fenced code blocks.

    Supports nested fences and differentiates between full-file and
    diff/patch payloads.
    """
    operations: List[Dict[str, Any]] = []

    lines = response.splitlines()
    in_block = False
    fence_depth = 0
    language = ""
    file_path = ""
    content_lines: List[str] = []

    for line in lines:
        if not in_block:
            match = _FILE_BLOCK_RE.match(line)
            if match:
                # Open a new primary fence
                language, file_path = match.group(1).strip(), match.group(2).strip()
                in_block = True
                fence_depth = 1
                content_lines = []
            # not the start of a file block → ignore
            continue

        # We are *inside* a file block ------------------------------------- #
        if line.strip().startswith("```"):
            # Is it an opening or closing fence?
            # Bare fence ⇒ closing one level
            if line.strip() == "```":
                fence_depth -= 1
            else:
                # e.g. ```python starts another (nested) fence
                fence_depth += 1

            if fence_depth == 0:
                # Primary fence closed – create operation
                kind = "diff" if language.lower() in _DIFF_LIKE_LANGUAGES else "full"
                operations.append(
                    {
                        "type": "modify_file",
                        "path": file_path,
                        "kind": kind,
                        "content": "\n".join(content_lines).strip("\n"),
                    }
                )
                # Reset state
                in_block = False
                language = ""
                file_path = ""
                content_lines = []
            # NOTE: We do *not* append the closing fence line to content
            continue

        # Regular content line
        content_lines.append(line)

    return operations


_TOOL_CALL_RE = re.compile(
    r"<tool_call>.*?<name>(?P<name>.*?)</name>.*?" r"<path>(?P<path>.*?)</path>.*?</tool_call>",
    re.DOTALL,
)


def _parse_tool_calls(response: str) -> List[Dict[str, Any]]:
    """
    Find and parse ``<tool_call>`` XML snippets.

    Supports the two built-in tools: ``read_file`` and ``list_files``.
    """
    operations: List[Dict[str, Any]] = []
    for match in _TOOL_CALL_RE.finditer(response):
        tool_name = match.group("name").strip()
        path = match.group("path").strip()
        if tool_name in {"read_file", "list_files"}:
            operations.append({"type": tool_name, "path": path})
    return operations
